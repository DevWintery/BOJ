# 문제

모든 창문은 4×4 그리드로 나타낼 수 있고, *를 이용해서 블라인드를 나타낸다. 상근이가 볼 수 있는 창문은 다음 5가지 상태 중 하나이다.

1.
....        
....
....
....

2.
****
....
....
​​​​​​​....

3.
****
****
....
​​​​​​​....

4.
****
****
****
​​​​​​​....

5.
****
****
****
​​​​​​​****

건너편 아파트의 한 층에는 N개의 창문이 있고, 총 M층 건물이다. 현재 건너편 아파트의 창문 상태가 주어졌을 때, 위의 5가지 상태가 각각 몇 번 나오는지 구하는 프로그램을 작성하시오.

첫째 줄에 M과 N이 공백으로 구분해서 주어진다. (1 ≤ M, N ≤ 100)

다음 줄에는 현재 건너편 아파트의 상태가 주어진다. 모든 창문은 문제 설명에 나온 것 처럼 4*4 그리드로 주어진다. 또, 창문과 창문은 '#'를 이용해서 구분한다. 아파트의 정보는 5M+1줄, 각 줄은 5N+1개 글자로 이루어져 있다.

출력은 총 5개 숫자이다. 문제 설명에 나온 순서대로 각 블라인드 타입이 몇 개 있는지를 출력한다. 숫자를 모두 합하면 M*N이 되어야 한다.

# 예시

## 입력
1 2
###########
#....#****#
#....#****#
#....#....#
#....#....#
###########

## 출력
1 0 1 0 0

# 풀이
(1 ≤ M, N ≤ 100) 으로 입력 변수가 그렇게 크지않기 때문에 O(N^2)의 시간복잡도로 문제를 해결할 수 있다고 봤다.

처음에는 M과 N이 주어져서 2차원 배열로 접근하려했지만 입력이 매우 규칙적이라 이를 string으로 변환하기만 하면 배열을 사용하지 않아도 될꺼같았다.

예를 들어 
****
****
....
​​​​​​​....

창문은
********....​​​​​​​....과 같다.


입력이 #######, 4*4 그리드의 반복이기 때문에 #으로 이루어진 string은 스킵한뒤 창문개수(N)개의 배열을 만들고 각 원소에 1*4 그리드를 4번 더하여 4*4 그리드를 string으로 변환하였다.
결과값은 map으로 저장하고 string과 같은 Key에 1씩 더하여 정답을 구성하였다. 이때 답이 순서대로 나와야하기 때문에 Hash를 사용하지않고 map을 사용하였다.

결과적으로 시간복잡도는 O(M * N) 으로 제작됐다. 