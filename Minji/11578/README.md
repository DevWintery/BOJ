# 문제
2015년 11월 28일은 기다리고 기다리던 제1회 IUPC가 열리는 날이다. IUPC는 Inha University Programming Contest의 약자로 인하대학교 IT공대 학부생이면 누구나 참여할 수 있는 프로그래밍 경시대회이다. 

IUPC의 총상금은 무려 110억 원이나 되며 고급스러운 점심과 많은 다과가 제공되어 참가자들이 대회에 집중할 수 있도록 최적의 환경을 제공한다. 그중 참가자들을 진정 열광시키는 것은 수많은 팀에게 추첨을 통해 문화상품권을 나눠준다는 점이다.

컴퓨터정보공학과에 재학 중인 강호는 대회에 참가하기 위해 팀원을 모집하려고 한다. IUPC가 여타 많은 대회와 다른 점이 있다면 문제의 수가 많고 팀원의 수가 무제한이라는 것이다. IUPC에서 모든 문제를 다 풀어 우승한 뒤 엄청난 부와 명예를 챙기고 싶은 강호는 모든 문제를 풀 수 있는 팀을 만들고 싶어 한다. 하지만 팀원의 수가 많으면 많을수록 자신에게 돌아오는 상금이 적어지기 때문에 최소한의 팀원으로 대회를 우승하고 싶어 한다.

강호가 선택할 수 있는 팀원의 목록과 각각의 팀원들이 해결할 수 있는 문제의 번호들이 주어졌을 때 강호가 IUPC에서 최소한의 팀원으로 모든 문제를 다 풀어 우승할 수 있도록 팀을 만들어보자.

# 입력
첫 번째 줄에 문제의 수 N과 강호가 팀원으로 고를 수 있는 학생들의 수 M이 공백을 구분으로 차례대로 주어진다. N과 M은 1이상 10이하의 자연수이다.

두 번째 줄부터 M개의 줄에 차례대로 i(1 ≤ i ≤ M)번 학생들이 풀 수 있는 문제의 개수 Oi와 i번 학생이 풀 수 있는 문제의 번호 Pij(1 ≤ j ≤ Oi, 1 ≤ Pij ≤ N)가 Oi개 주어진다.

# 출력
모든 문제를 풀 수 있으면서 팀원의 수가 가장 적은 팀을 구해 팀원의 수를 출력한다. 만약 모든 문제를 풀 수 있는 팀을 만들 수 없다면 -1을 출력한다,

----------------------------------------------------
# 해설
- 결국 모든 문제를 해결해야하는 것이기 때문에 문제를 기준으로 풀 수 있는 학생들을 map으로 저장하기로 했다.
- 그리고 모든 문제를 순환하면서 모든 문제를 풀 수 있는 학생들의 조합을 만들어냈고, 그 조합들 중 수가 가장 적은 것이 답이라고 생각하여 풀었다.

# 반성(?)
- 비트마스크를 사용한 팀 구성 탐색
    - problems = (1 << N) - 1: 모든 문제를 해결했을 때의 상태.
    - mask를 활용해 모든 학생 조합을 탐색 (1 ≤ mask < (1 << M))
    - __builtin_popcount(mask): 현재 조합의 학생 수.
    - solve |= students[i]: 현재 조합이 풀 수 있는 문제를 비트 OR 연산으로 갱신.

    ```cpp
        students[0] = 0011 (3)
        students[1] = 1100 (12)
        students[2] = 0110 (6)
        //모든 문제(1111)를 해결할 수 있는 최소 조합을 찾을 수 있다
    ```

비트마스크를 활용할 줄은 몰랐다.. 너무 문제를 직관적으로만 해결하는 버릇이 있다.


